@page "/quick"

<PageTitle>Quick Sort</PageTitle>

<div class="d-flex gap-3 mb-3">
    @for (int i = 0; i < pole.Length; i++)
    {
        string textColor = (i >= low && i <= high) ? "text-primary" : "text-secondary";
        
        if (i == this.i)
        {
            <div class="fs-1 @textColor border-bottom border-primary border-3">@pole[i]</div>
        }
        else if (i == this.j)
        {
            <div class="fs-1 @textColor border-bottom border-secondary border-3">@pole[i]</div>
        }
        else
        {
            <div class="fs-1 @textColor">@pole[i]</div>
        }
    }
</div>

<div class="fs-1 mb-3">pivot @pivot</div>

<button class="btn btn-primary" @onclick="DalsiIterace">Next Iteration</button>

<div class="fs-1 mb-3">
    @foreach(var partition in partitions)
    {
        <div class="fs-1">@partition.low : @partition.high</div>
    }
</div>

<div class="rz-p-0 rz-p-md-12">
    <RadzenChart>
        <RadzenColumnSeries Data="@Data" CategoryProperty="Caption" ValueProperty="Data">
            <RadzenSeriesDataLabels Visible="true" />
        </RadzenColumnSeries>
        <RadzenLegend Visible="false" />
    </RadzenChart>
</div>

@code {
    class Partition
    {
        public int low;
        public int high;  

        public Partition(int low, int high)
        {
            this.low = low;
            this.high = high;
        }
    }

    Queue<Partition> partitions = new Queue<Partition>();

    int low;
    int high;
    int pivot;
    int j;
    int i;

    DataItem[] Data => pole.Select((x, i) => new DataItem((i == j) ? $">{i + 1}<" : $"{i + 1}", x)).ToArray();

    private int[] pole = ReservoarSampling.Generate(20, 20);


    protected override void OnInitialized()
    {
        Inicializace();
    }

    void Inicializace()
    {
        low = 0;
        high = pole.Length - 1;
        pivot = pole[high];
        i = 0;
        j = 0;
    }

    void DalsiIterace()
    {
        if (j <= high - 1)
        {
            if (pole[j] <= pivot)
            {
                int tmp = pole[i];
                pole[i] = pole[j];
                pole[j] = tmp;

                ++i;
            }

            ++j;
        }
        else
        {
            int tmp = pole[i];
            pole[i] = pole[j];
            pole[j] = tmp;

            Partition left = new Partition(low, i - 1);
            Partition right = new Partition(i + 1, high);

            if (left.low < left.high)
            {
                partitions.Enqueue(left);
            }

            if (right.low < right.high)
            {
                partitions.Enqueue(right);
            }

            if(partitions.Count > 0)
            {
                Partition partition = partitions.Dequeue();

                low = partition.low;
                high = partition.high;
                pivot = pole[high];
                i = low;
                j = low;
            }
            else
            {
                Inicializace();
            }

        }
    }
}
