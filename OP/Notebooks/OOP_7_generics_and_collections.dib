#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"}]}}

#!markdown

## Generické datové typy a kolekce
---

#!markdown

Generika (C#, Java) nebo šablony v C++, zmožňují odložit přesnou definici použitého datového typu v rámci datového typu, například třídy nebo rozhraní. V jazyce C se pro podobné účely používá příkaz textového preprocecoru #define.

Generika poskytují vetší znovu použitelnost kódu, zlepšuje typovou bezpečnost a celkový výkon (není nutný [boxing](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing) u hodnotových typů). Nejčastější aplikace je v rámci kolekcí. Je doporučováno vždy preferovat generické třídy a metody před jejími negenerickými verzemi

V následujícím příkladu je ukázka definice generické třídy sklad, který představuje zásobník s pevnou délkou:

#!csharp

class Sklad<T>
{
    T[] data;
    private int pocet;

    public Sklad(int kapacita)
    {
        data = new T[kapacita];
    }

    public void Zaloz(T objekt)
    {
        data[pocet++] = objekt;
    }

    public T Vyloz()
    {
        return data[--pocet];
    }
}

#!markdown

A při použití této třídy zvolíme konrétní typ, který se použije místo generického parametru `T`.

#!csharp

Sklad<int> skladInt = new Sklad<int>(10);
skladInt.Zaloz(1);
int celeCislo = skladInt.Vyloz();

Sklad<string> skladString = new Sklad<string>(10);
skladString.Zaloz("Ahoj");
string retezec = skladString.Vyloz();

Console.WriteLine(retezec);

#!markdown

### Generic Constraints

#!markdown

Pomocí Generic Constraints můžeme omezit jaké typy můžeme použít pro generický parametr a tím také rozšířit operace, které s generickým typem můžeme provádět. V následujícím příkladu jsme omezili generický typ `T` třídy `Sklad<T>` na třídu `Zviratko` a její potomky.

#!csharp

abstract class Zviratko
{
    public string Jmeno { get; set; }
    public abstract string Zvuk();

    protected Zviratko(string jmeno)
    {
        Jmeno = jmeno;
    }
}

class Pejsek : Zviratko
{
    public Pejsek(string jmeno) : base(jmeno)
    {
    }

    public override string Zvuk()
    {
        return "Haf haf";
    }
}

#!markdown

Díky tomu můžeme například v metodě `NajdiPodleJmena` použít property `Jmeno` a vyhledat zvířátko podle jména. 

#!csharp

class Sklad<T> where T : Zviratko
{
    T[] data;
    private int pocet;

    public Sklad(int kapacita)
    {
        data = new T[kapacita];
    }

    public void Zaloz(T objekt)
    {
        data[pocet++] = objekt;
    }

    public T Vyloz()
    {
        return data[--pocet];
    }

    public T NajdiPodleJmena(string jmeno)
    {
        return data.First(x => x.Jmeno == jmeno);
    }
}

#!csharp

Sklad<Zviratko> zviratka = new Sklad<Zviratko>(10);

zviratka.Zaloz(new Pejsek("Rex"));
zviratka.Zaloz(new Pejsek("Fik"));
zviratka.Zaloz(new Pejsek("Zeryk"));

Zviratko zviratko = zviratka.NajdiPodleJmena("Fik");

Console.WriteLine($"{zviratko.Jmeno} dela {zviratko.Zvuk()}")

#!markdown

---
Více se o možnostech o generice a Generic Constraints můžete dozvědět například zde:

[Generic classes and methods. 2022](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics)

[Constraints on type parameters (C# Programming Guide). 2022](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters)

#!markdown

### Dynamické pole List

Generická třída List<T> představuje implementaci dynamického pole. Kdy pole s pevnou délkou (Array) má pevně danou délku, kterou není možné změnit. Dynamické pole umožňuje přidávat a odebírat prvky do již existujícího pole protože v případě potřeby si dynamické pole alokuje víc paměti.

#!markdown

Instanci třídy List<int> definujeme následujícím způsobem. Po vytvoření instance neobsahuje žádné prvky.

#!csharp

List<int> cisla = new List<int>(); 

#!markdown

Prvky inicializujeme stejným způsobem jako pole, tedy seznamem prvků ve složených závorkách oddělených čárkou.

#!csharp

List<int> cisla = new List<int>() { 1, 2, 3 }; 

#!markdown

K prvkům přistupujeme pomocí operátoru indexace `[]` nebo pomocí cyklu foreach protože List<int> implementuje rozhraní `IEnumerable`. V následujících příkladech si ukážeme nejprve použití operátoru indexace a potom cyklu `foreach`.

#!csharp

// Prvni prvek
Console.WriteLine(cisla[0]);

// Druhy prvek
Console.WriteLine(cisla[1]);

// Treti prvek
Console.WriteLine(cisla[2]);

#!csharp

foreach (int cislo in cisla)
{
    Console.WriteLine(cislo);
}

#!markdown

V následujících příkladech projdeme základní operace s polem:

#!csharp

List<char> znaky = new List<char>() { 'a', 'b', 'c' };

znaky.Add('x');         // Vložení na konec
znaky.Insert(1, 'x');   // Vložení na libovolnou pozici
znaky.Insert(0, 'x');   // Vložení na začátek
znaky.RemoveAt(1);      // Odebrání prvku z indexu
znaky.Remove('b');      // Odebrání prvků dle hodnoty
znaky.Clear();          // Odebrání všech prvků

#!markdown

`List<T>` je třída a tedy referenční typ, přiřazením se zkopíruje reference, která odkazuje na stejné data v paměti.

#!csharp

List<char> original = new List<char>() { 'a', 'b', 'c'};

List<char> kopie = original;

object.ReferenceEquals(original, kopie)

#!markdown

Hlubokou kopii instance třídy `List<T>` můžeme například vytvořit předáním původního listu jako argumentu konstruktoru. V příkladu vytváříme hlubokou kopii instance třídy List<int> ale pokud by jako prvky byly referenční typy, tak kopie jednotlivých prvků by opět byly jen reference na stejný objekt.

#!csharp

List<char> original = new List<char>() { 'a', 'b', 'c' };

List<char> kopie = new List<char>(original);

object.ReferenceEquals(original, kopie)

#!markdown

###  Asociativní pole Dictionary

Obyčejné pole ukládá pouze hodnoty. Asociativní pole ukládá dvojici klíč a hodnota. Díky klíči je potom možné velmi rychle vyhledávat vložené hodnoty. Díky ukládání klíče zabírá tento kontejner více paměti.

#!markdown

Instanci třídy `Dictionary<TKey,TValue>` definujeme následujícím způsobem. Po vytvoření instance neobsahuje žádné prvky. Jako příklad budeme mít asociativní pole studentí, kdy klíčem bude id studenta typu int a hodnotou reference na instanci třídy `Student`.

#!csharp

class Student
{
    public string Jmeno {get; set;}
    
    public Student(string jmeno)
    {
        Jmeno = jmeno;
    }
}

#!csharp

Dictionary<string, Student> studenti = new Dictionary<string, Student>();

#!markdown

Prvky inicializujeme například následujícím způsobem kdy klíč je uvedený v hranatých závorkách a je mu přiřazená hodnota operátorem přiřazení: 

#!csharp

Dictionary<string, Student> studenti = new Dictionary<string, Student>()
{
    ["A100"] = new Student("Jiri"),
    ["A200"] = new Student("Jiri"),
    ["A300"] = new Student("Jiri")
};

#!markdown

Nebo starším zápisem, kdy každý záznam je uvedený ve složených závorkách jako pár klíč hodnota oddělený čárkou:

#!csharp

Dictionary<string, Student> studenti = new Dictionary<string, Student>()
{
    { "A100", new Student("Jiri") },
    { "A200", new Student("Jiri") },
    { "A300", new Student("Jiri") }
};

#!markdown

K prvkům přistupujeme pomocí indexeru v hranatých závorkách. V případě, že klíč neexistuje, tak metoda vyvolá výjimku a předpokládáme tedy, že klíč, který hledáme by měl v případě správného chování programu existovat.

#!csharp

try
{
    Student student = studenti["A100"];
}
catch (KeyNotFoundException)
{
    Console.WriteLine("Klíč neexistuje");
}

#!markdown

Nebo můžeme použít metodu `TryGet`, kdy předpokládáme, že klíč nemusí vždy existovat.

#!csharp

bool exituje = studenti.TryGetValue("A200", out Student student);
           
if(!exituje)
{
    Console.WriteLine("Klíč neexistuje");
}

#!markdown

`Dictionary` můžeme také procházet pomocí cyklu `foreach` a to jak zvlášť hodnoty, klíče nebo pár klíč a hodnota.

#!csharp

foreach (Student student in studenti.Values)
{
    Console.WriteLine(student.Jmeno);
}

foreach (string key in studenti.Keys)
{
    Console.WriteLine(key);
}
        
foreach (KeyValuePair<string,Student> zaznam in studenti)
{
    Console.WriteLine($"{zaznam.Key}: {zaznam.Value.Jmeno}");
}

#!markdown

Prvek na konec listu vložíme pomocí metody `Add`. Parametry jsou klíč a hodnota prvku. Pokud vložíme již jednou existující klíč, tak metoda vyvolá výjímku.

#!csharp

try
{
    studenti.Add("A100", new Student("Katerina"));
}
catch (ArgumentException)
{
    Console.WriteLine("Prvek se zadaným klíčem už existuje");
}

#!markdown

Před přidáním prvku můžeme otestovat, že klíč existuje pomocí metody `ContainsKey`.

#!csharp

if(!studenti.ContainsKey("A100"))
{
    studenti.Add("A100", new Student("Katerina"));
}
else
{
    Console.WriteLine("Prvek se zadaným klíčem už existuje");
}

#!markdown

Prvek také můžeme vložit pomocí metody `TryAdd`. Metoda vrátí `false`, pokud se vložení nepovede.

#!csharp

if (!studenti.TryAdd("A100", new Student("Katerina")))
{
    Console.WriteLine("Prvek se zadaným klíčem už existuje");
}

#!markdown

Prvek odstraníme například pomocí metody `Remove`:

#!csharp

bool removed = studenti.Remove("A100");

Console.WriteLine(removed);

#!markdown

---
Více se o různých typech kolekcích v jazyce C# dozvíte například zde:

[Collections (C#). Microsoft Docs. 2022](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/collections)
    
